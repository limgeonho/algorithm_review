## 인프런

```
DFS, BFS 문제 풀기
=================================================================================================================================
강의
===========================================
탐색&시뮬레이션
리스트의 len()가지고 범위 조절하기
리스트에 추가로 리스트를 더하는 방법 => [] + [] 하면 끝
append vs extend => append는 원소를 그대로 넣어버리고 extend는 원소를 1번 까서 넣는다
2차원 리스트 a[i][j], a[j][i] 하면 가로 탐색, 세로탐색임
리스트의 마지막에 추가한다 => append(), 리스트의 맨 앞에 넣는다 => list.insert(넣을 자리, '넣을 원소')
2차원 리스트에서 내부의 2차원 리스트를 탐색할때(네모안에 네모) 4중 for문 사용해야함 => for i in range(3): for j in range(3): for k in range(3): for s in range(3): => a[i*3+k][j*3+s] 

[수의합] => 슬라이딩 도어
[사과나무, 곳감] => 2차원 리스트의 범위를 줄였다 늘였다
[스도쿠 검사] => 4중 for문

===========================================
이분탐색 & 그리디알고리즘
이분탐색문제는 시작점과 끝점을 찾는 것이 중요함 + start, end, mid가 list의 인덱스가 아니라 직접 숫자값인 경우도 생각하기!!!
그리디 알고리즘은 대부분 sort()가 중요함

[랜선 자르기] => 2분 탐색활용문제
[마구간 정하기] => ??
[증가 수열 만들기] => 그리디?
[역수열] => 그리디라고?

===========================================
자료구조활용(스택, 큐, 힙, 해시)

스택 - LIFO
무작정 규칙을 찾는다기 보다는 자료구조나 어떤 개념을 묻는 것인지 생각할 것!!!
숫자를 리스트에 하나씩 잘라서 넣는 방법 => 54321 => tmp = list(map(int, str(54321)))

큐 - FIFO
queue => appendleft() 왼쪽에 넣기
리스트가 앞에서 빠지고 계속 다시 뒤로 들어간다? => queue => deque

해시 - 딕셔너리
tmp = dict() => for key, value in tmp.items(): 하면 key, value 쌍을 뽑아낼 수 있다.
임의의 문자열의 단어 개수를 딕셔너리에 카운팅해서 넣는 법 => str1 = {} for s in word: str1[s] = str1.get(s, 0)+1

힙큐 - heapq는 기본적으로 최소힙으로 작동함
(최소힙)
import heapq
a = []
heapq.heappush(a, n)
heapq.heappop(a)
(최대힙) => 넣을 때 - 붙이고 뺄 때 - 붙임
import heapq
a = []
heapq.heappush(a, -n)
-heapq.heappop(a)

===========================================
완전탐색 - 기초

재귀함수는 항상 종료조건을 생각해야함(스택구조 활용함)
부분집합 - 부분집합에서는 if로 백트래킹 조건 생각하기
기본적인 순열, 조합, 중복순열, 부분집합은 전부 암기 + 암기한 것에서 추가 파라미터로 값을 들고 다니는 경우 많음!
for comb in combinations(arr, 3) => comb에 조합된 결과들이 하나씩 출력된다.
인접행렬, 인접리스트, 체크배열

[바둑이 승차] - 기존의 백트래킹으로는 시간초과... + 앞으로 판단해야하는 경우들도 미리 pruning하는 과정이 필요한 문제!!
[동전교환] - 중복순열문제인데 L로 정답을 구하는 문제 + 백트래킹 조건 2개(하나는 기존의 생각하던 조건 + 나머지 하나가 성립하는 조건 하에 앞으로 안해도 되는 것 pruning) + 나는 이문제 그리디로 생각함
[수열 추측하기] - 이항계수 만드는 식은 직접 만들어야함(이항계수인 것도 규칙을 통해서 찾긴 해야함)

===========================================
깊이 / 넓이 우선 탐색(DFS / BFS)
DFS - 해당 문제가 부분집합형인지 순열이나 조합형 문제 인지 파악하는 것이 중요함
BFS - 방향 설정기본 세팅 + deque + 초기값을 deque에 넣기 + check하기 + nextX, nextY는 각각의 X와 Y의 범위, 조건 확인
DFS에서 다시 돌아가는 경우가 있으면 방금 한 행위를 뒤에서 다시 지나갈 수 있도록 풀어줘야 한다. => check[x][y]=1 DFS(x, y) check[x][y]= => DFS함수 전후로 대칭구조
2차원 리스트를 탐색하는 DFS나 BFS에서 방문처리를 위해서는 똑같은 크기의 0으로 만들어진 2차원리스트를 만들어서 기록한다.
재귀 제한풀기 => sys.setrecursionlimit(10**6)
BFS에서는 항상 Q에서 뽑고 다음 영역으로 나아갈 때 범위 체크하기!!!


[양팔저울] - 단순 부분집합이나 수열조합이 아님 + 경우가 3개로 나눠줘야함
[동전교환] - 그림을 그려서 해봐야함 가지치기 그림 
[동전 분배하기] - 이 문제도 그림을 그려서 L과 sum을 설계
[알파코드] - 그림그려서 판단 + 증가하는 경우까지 따로 판단
[사다리 타기] - 2차원 리스트에서 길찾기 문제 중 거꾸로 올라가는 유형 => 복습하기

===========================================
다이나믹 프로그래밍

bottom-up == 이게 찐 다이나믹 프로그래밍임
top-down == 재귀 + 메모이제이션(dy리스트에 기록하지 않는 다면 그냥 단순 재귀일뿐...)
메모이제이션
기록용 dy리스트를 작성할 때 해당 dy[x]가 어떤 것을 의미하는 지 정의해야함 ex) [가장 높은 탑 쌓기] => dy[x]는 x번째 벽돌이 가장 맨 위에 왔을 때 탑의 높이 
냅색에서 dy리스트의 의미는 dy[x] => 최대 x라는 무게에서 담을 수 있는 최대 가치
냅색문제는 두 가지 유형으로 나눠진다 (1. 상품의 개수 무제한, 2. 상품의 개수가 정해짐)
위상정렬 => 진입차수 설정 필요(진입차수가 0? == 바로 시작할 수 있는 노드)

대표적인 DP종류
피보나치 수
LIS
냅색
플로이드 와샬
위상정렬


===========================================
딕셔너리 관련 
https://wikidocs.net/16 페이지 참고

딕셔너리 요소 삭제하기
>>> del a[1] => key를 입력하면 해당 key, value 모두 삭제됨
>>> a
{2: 'b', 'name': 'pey', 3: [1, 2, 3]}

.keys()
>>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
>>> a.keys()
dict_keys(['name', 'phone', 'birth'])

.values()
>>> a.values()
dict_values(['pey', '0119993323', '1118'])

.items()
>>> a.items()
dict_items([('name', 'pey'), ('phone', '0119993323'), ('birth', '1118')])

.get('찾으려는 값', '없다면 default값')
>>> a.get('foo', 'bar')
'bar'

in => 해당 key가 딕셔너리에 있는지 확인
>>> a = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
>>> 'name' in a
True
>>> 'email' in a
False

DFS에서 부분 집합형 문제를 구할 때 백트래킹 조건으로 현재 연산하지 않았지만 앞으로 전부 연산했을 때 결과랑 비교하는 조건도 생각하기
=> 바둑이 승차 문제

순열, 조합, 중복순열 => if 조건만
부분집합 => if ~ else 까지

DFS에서는 항상 다시 돌아왔을 때 방문 조건을 다시 풀어줘야(원상복구) 진행이 가능함

DFS에서 부분집합 형인지 아니면 순열, 조합 형인지?
=> 부분집합 : O, X선택을 해야함
=> 부분집합은 전체 원소를 끝까지 돌아야함 + O, X
=> 순열조합 : 순서가 중요한지 뽑아서 나열
=> 순열조합은 원하는 개수까지 돌 수 있음 + 순서

휴가 문제 같은 경우 부분집합형 문제이지만 원소들을 전부 도는 것이 아니라 특정 조건까지만 도는 경우도 있음(조건 도달시 종료)

BFS문제에서 deque에서 나온 값이 다음 값으로 넘어갈때 무조건 조건 범위내 검사 먼저 진행하자
=> 송아지 찾기 문제에서 범위 검사를 뒤에 하니까 에러남;;

```

