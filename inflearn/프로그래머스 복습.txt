[프로그래머스 레벨1]
- rjust, ljust, join 함수
- 연산횟수가 정해져 있으면 for문의 최대값으로 제한(0.XX)
- 소수인지 판별은 n % 1 == 0 이면 소수!
- 리스트 뒤집기 list.reverse() or arr[::-1] + 슬라이싱
- list.sort() or sorted(list) / list자체를 바꿈 or 바뀐 리스트를 반환 <= 변수에 저장해줘야함
- ''.join(list) => 문자열로 나옴
- map(function, iterable)
- isalpha(), isdigit(), isalnum()
- 알파벳을 숫자로 ord / 숫자를 알파벳으로 chr
- 리스트에서 원하는 요소를 찾을때 list.index("찾는 요소")
- f-string => f'{변수} 입니다.'
- for 문 멈추기 => break / for 문 건너 뛰기 => continue
- len(s) in (4, 6) => s의 길이가 4나 6이라는 숫자에 포함되어 있나?
- answer = ''.join(sorted(s, reverse=True)) => s라는 리스트를 거꾸로 정렬
- sorted(a, key=lambda x:x[0])
- 문자열에서 특정 문자 세기 => cnt = strings.count('letter')
- sum(range(3, 6)) => 3부터 5까지 숫자의 합을 계산해서 return
- list에서 문자 뽑기 => list.pop() => 마지막 원소
- combinations 사용하기 => list(combinations(arr, 2))
- set에 넣기 => set(arr)
- for idx, value in enumerate(list):
- for p, c in zip(participant, completion) => participant, completion의 리스트를 빼고 각각의 p, c로 뽑아냄
- zip은 서로 다른 리스트를 동시에 깔때 사용하면 좋음
- Counter은 list에 넣어서 반환해야 사용할 수 있음 => list(Counter(arr).keys())[0]
- list에서 특정 value의 개수를 찾는 방법 => list.count("value")


[프로그래머스 레벨2]
- s.split() => 하면 리스트로 반환된다
- s.split()할때 s.split(' ')로 해야 중복된 ' '을 무시하지 않음
- s.capitalize() vs s.title() => capitalize()는 문자열 전체 중 첫 글자만 / title()는 단어마다 + 첫 문자적용(첫 글자가 숫자면 두 번째 문자를 대문자로)
- 행렬의 곱셈 암기 하기
- max(land[i-1][:j] + land[i-1][j+1:]) => 리스트 + 리스트는 리스트로 나옴, 그 중에서 최대 값
- 기록용으로 list를 만들어서 append와 pop으로 관리하는 방법도 좋음
- 리스트의 pop(0)을 하면 첫 문자를 뽑고 return 함 => list.pop(0) => list의 첫 문자 return
- 2차원 리스트 => 1차원 리스트로 바꿀 수 있음 => for i in range(n**2): + x = i // n, y = i % n
- 중복순열 => list(product, repeat = 원하는 개수) 
- 원하는 원소의 위치 찾기 => list.index('찾고자 하는 value')
- 확실하게 그냥 list.pop(0)보다 deque.popleft()가 빠르다!! => 앞에서 원소 뽑을 일 있으면 deque사용하자
- rfind(), find() => 일반적인 find는 왼쪽부터 찾아간다 하지만 rfind()는 오른쪽부터 찾기 시작함
- bin() => 2진수 문자열로 바꿔줌
- 리스트를 복사하는 방법 => 왜? 리스트는 arr1 = arr2하면 arr2의 주소가 복사되기 때문에 arr1과 arr2가 같은 리스트를 공유한다
		         => 따라서, arr1 = arr2[:]로 복사한다.  

===========================================
[프로그래머스 복습할 문제]
- 숫자의 표현 -> 시간초과 났었음 -> 특정 조건 하에서 반복한다면 while문 => O
- 가장 큰 정사각형 찾기 -> 2차원 리스트안에서 또 다른 정사각형 탐색? -> dp를 생각해보자 => O
- 방문 길이 -> 좌표상에서 움직인 선분의 길이 -> set을 활용해서 지나온 길의 좌표를 넣어준다(이때, 양방향으로 넣는다) => O(중복처리는 set활용!)
===========================================
- 스킬트리 -> list.pop(0)
- 점프와 순간이동 -> 원하는 목적지(값)로 가기 위해서는 bottom-up보다 top-down이 편한 경우도 생각
- n*2배열 자르기 -> 2차원 리스트를 1차원으로 계산하기 (row major order사용 + 필요한 부분만)
- 전력망 둘로 나누기 
===========================================
모음사전 -> 중복순열을 이용(perm_with or product) => list(product, repeat = 원하는 개수) + 리스트에서 원하는 value의 인덱스
구명보트 -> 문제 잘 읽기
===========================================
영어 끝말잇기 -> 조건에 맞게 잘 분기처리만 하면됨
===========================================
2개 이하로 다른 비트 -> 단순 구현으로 하면 에러남

DFS, BFS 문제 풀기
=================================================================================================================================
강의
===========================================
탐색&시뮬레이션
리스트의 len()가지고 범위 조절하기
리스트에 추가로 리스트를 더하는 방법 => [] + [] 하면 끝
append vs extend => append는 원소를 그대로 넣어버리고 extend는 원소를 1번 까서 넣는다
2차원 리스트 a[i][j], a[j][i] 하면 가로 탐색, 세로탐색임
리스트의 마지막에 추가한다 => append(), 리스트의 맨 앞에 넣는다 => list.insert(넣을 자리, '넣을 원소')
2차원 리스트에서 내부의 2차원 리스트를 탐색할때(네모안에 네모) 4중 for문 사용해야함 => for i in range(3): for j in range(3): for k in range(3): for s in range(3): => a[i*3+k][j*3+s] 

[수의합] => 슬라이딩 도어
[사과나무, 곳감] => 2차원 리스트의 범위를 줄였다 늘였다
[스도쿠 검사] => 4중 for문

===========================================
이분탐색 & 그리디알고리즘
이분탐색문제는 시작점과 끝점을 찾는 것이 중요함 + start, end, mid가 list의 인덱스가 아니라 직접 숫자값인 경우도 생각하기!!!
그리디 알고리즘은 대부분 sort()가 중요함

[랜선 자르기] => 2분 탐색활용문제
[마구간 정하기] => ??
[증가 수열 만들기] => 그리디?
[역수열] => 그리디라고?

===========================================
자료구조활용(스택, 큐, 힙, 해시)

스택 - LIFO
무작정 규칙을 찾는다기 보다는 자료구조나 어떤 개념을 묻는 것인지 생각할 것!!!
숫자를 리스트에 하나씩 잘라서 넣는 방법 => 54321 => tmp = list(map(int, str(54321)))

큐 - FIFO
queue => appendleft() 왼쪽에 넣기
리스트가 앞에서 빠지고 계속 다시 뒤로 들어간다? => queue => deque

해시 - 딕셔너리
tmp = dict() => for key, value in tmp.items(): 하면 key, value 쌍을 뽑아낼 수 있다.
임의의 문자열의 단어 개수를 딕셔너리에 카운팅해서 넣는 법 => str1 = {} for s in word: str1[s] = str1.get(s, 0)+1

힙큐 - heapq는 기본적으로 최소힙으로 작동함
(최소힙)
import heapq
a = []
heapq.heappush(a, n)
heapq.heappop(a)
(최대힙) => 넣을 때 - 붙이고 뺄 때 - 붙임
import heapq
a = []
heapq.heappush(a, -n)
-heapq.heappop(a)

===========================================
완전탐색 - 기초

재귀함수는 항상 종료조건을 생각해야함(스택구조 활용함)
부분집합 - 부분집합에서는 if로 백트래킹 조건 생각하기
기본적인 순열, 조합, 중복순열, 부분집합은 전부 암기 + 암기한 것에서 추가 파라미터로 값을 들고 다니는 경우 많음!
for comb in combinations(arr, 3) => comb에 조합된 결과들이 하나씩 출력된다.
인접행렬, 인접리스트, 체크배열

[바둑이 승차] - 기존의 백트래킹으로는 시간초과... + 앞으로 판단해야하는 경우들도 미리 pruning하는 과정이 필요한 문제!!
[동전교환] - 중복순열문제인데 L로 정답을 구하는 문제 + 백트래킹 조건 2개(하나는 기존의 생각하던 조건 + 나머지 하나가 성립하는 조건 하에 앞으로 안해도 되는 것 pruning) + 나는 이문제 그리디로 생각함
[수열 추측하기] - 이항계수 만드는 식은 직접 만들어야함(이항계수인 것도 규칙을 통해서 찾긴 해야함)

===========================================
깊이 / 넓이 우선 탐색(DFS / BFS)
DFS - 해당 문제가 부분집합형인지 순열이나 조합형 문제 인지 파악하는 것이 중요함
BFS - 방향 설정기본 세팅 + deque + 초기값을 deque에 넣기 + check하기 + nextX, nextY는 각각의 X와 Y의 범위, 조건 확인
DFS에서 다시 돌아가는 경우가 있으면 방금 한 행위를 뒤에서 다시 지나갈 수 있도록 풀어줘야 한다. => check[x][y]=1 DFS(x, y) check[x][y]= => DFS함수 전후로 대칭구조
2차원 리스트를 탐색하는 DFS나 BFS에서 방문처리를 위해서는 똑같은 크기의 0으로 만들어진 2차원리스트를 만들어서 기록한다.
재귀 제한풀기 => sys.setrecursionlimit(10**6)
BFS에서는 항상 Q에서 뽑고 다음 영역으로 나아갈 때 범위 체크하기!!!


[양팔저울] - 단순 부분집합이나 수열조합이 아님 + 경우가 3개로 나눠줘야함
[동전교환] - 그림을 그려서 해봐야함 가지치기 그림 
[동전 분배하기] - 이 문제도 그림을 그려서 L과 sum을 설계
[알파코드] - 그림그려서 판단 + 증가하는 경우까지 따로 판단
[사다리 타기] - 2차원 리스트에서 길찾기 문제 중 거꾸로 올라가는 유형 => 복습하기

===========================================
다이나믹 프로그래밍

bottom-up == 이게 찐 다이나믹 프로그래밍임
top-down == 재귀 + 메모이제이션(dy리스트에 기록하지 않는 다면 그냥 단순 재귀일뿐...)
메모이제이션
기록용 dy리스트를 작성할 때 해당 dy[x]가 어떤 것을 의미하는 지 정의해야함 ex) [가장 높은 탑 쌓기] => dy[x]는 x번째 벽돌이 가장 맨 위에 왔을 때 탑의 높이 
냅색에서 dy리스트의 의미는 dy[x] => 최대 x라는 무게에서 담을 수 있는 최대 가치
냅색문제는 두 가지 유형으로 나눠진다 (1. 상품의 개수 무제한, 2. 상품의 개수가 정해짐)
위상정렬 => 진입차수 설정 필요(진입차수가 0? == 바로 시작할 수 있는 노드)

대표적인 DP종류
피보나치 수
LIS
냅색
플로이드 와샬
위상정렬


===========================================
딕셔너리 관련 
https://wikidocs.net/16 페이지 참고

딕셔너리 요소 삭제하기
>>> del a[1] => key를 입력하면 해당 key, value 모두 삭제됨
>>> a
{2: 'b', 'name': 'pey', 3: [1, 2, 3]}

.keys()
>>> a = {'name': 'pey', 'phone': '0119993323', 'birth': '1118'}
>>> a.keys()
dict_keys(['name', 'phone', 'birth'])

.values()
>>> a.values()
dict_values(['pey', '0119993323', '1118'])

.items()
>>> a.items()
dict_items([('name', 'pey'), ('phone', '0119993323'), ('birth', '1118')])

.get('찾으려는 값', '없다면 default값')
>>> a.get('foo', 'bar')
'bar'

in => 해당 key가 딕셔너리에 있는지 확인
>>> a = {'name':'pey', 'phone':'0119993323', 'birth': '1118'}
>>> 'name' in a
True
>>> 'email' in a
False

dfdsf

